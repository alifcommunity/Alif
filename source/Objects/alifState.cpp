


#include "alif.h"
//#include "alifCore_ceval.h"
#include "alifCore_code.h"          
//#include "alifCore_dtoa.h"         
//#include "alifCore_frame.h"
#include "alifCore_initconfig.h"
//#include "alifCore_object.h"       
//#include "alifEore_pyerrors.h"
#include "alifCore_alifLifeCycle.h"
#include "alifCore_alifMem.h"      
#include "alifCore_alifState.h"
#include "alifCore_runtimeInit.h"
//#include "alifCore_sysModule.h"    
//#include "alifCore_weakref.h"    















































#ifdef HAVE_THREAD_LOCAL
ALIF_THREAD_LOCAL AlifThreadState* alifTssTState = nullptr;
#endif

























































































































































































































































































































static const AlifRuntimeState initial = ALIFRUNTIMESTATE_INIT(alifRuntime);
ALIFCOMP_DIAGPOP

#define NUMLOCKS 9













static int
alloc_forRuntime(AlifThreadTypeLock _locks[NUMLOCKS])
{


	AlifMemAllocatorEx old_alloc;
	alifMem_setDefaultAllocator(AlifMem_Domain_Raw, &old_alloc);

	for (int i = 0; i < NUMLOCKS; i++) {
		AlifThreadTypeLock lock = alifThread_allocate_lock();
		if (lock == NULL) {
			for (int j = 0; j < i; j++) {
				alifThread_free_lock(_locks[j]);
				_locks[j] = NULL;
			}
			break;
		}
		_locks[i] = lock;
	}

	alifMem_setAllocator(AlifMem_Domain_Raw, &old_alloc);
	return 0;
}




































AlifStatus alifRuntimeState_Init(AlifRuntimeState* _runtime)
{



	//void* openCodeHook = _runtime->openCodeHook;
	//void* openCodeUserData = _runtime->openCodeUserData;
	//AlifAuditHookEntry* auditHookHead = _runtime->auditHooks.head;


	//AlifSizeT unicode_next_index = _runtime->unicodeState.IDs.nextIndex;

	AlifThreadTypeLock locks[NUMLOCKS];
	if (alloc_forRuntime(locks) != 0) {
		return ALIFSTATUS_NO_MEMORY();
	}

	if (_runtime->initialized) {


		memcpy(_runtime, &initial, sizeof(*_runtime));
	}

	//if (GILSTATE_TSS_INIT(_runtime) != 0) {
	//	alifRuntimeState_fini(_runtime);
	//	return ALIFSTATUS_NO_MEMORY();
	//}

	//if (alifThread_tssCreate(&_runtime->trashTssKey) != 0) {
	//	alifRuntimeState_fini(_runtime);
	//	return ALIFSTATUS_NO_MEMORY();
	//}

	//init_runtime(_runtime, open_code_hook, open_code_userdata, audit_hook_head,
		//unicode_next_index, _locks);

	return ALIFSTATUS_OK();
}























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































AlifInterpreterState* alifInterpreterState_head()
{
	return alifRuntime.alifInterpreters.head;
}

AlifInterpreterState* alifInterpreterState_main()
{
	return alifInterpreter_state_main();
}



AlifInterpreterState* alifInterpreterState_next(AlifInterpreterState* _interp) {
	return _interp->next;
}
